// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/staking.proto

package types

import (
	bytes "bytes"
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	_ "github.com/golang/protobuf/ptypes/duration"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	_ "github.com/regen-network/cosmos-proto"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Description defines a validator description.
type Description struct {
	Moniker  string `protobuf:"bytes,1,opt,name=moniker,proto3" json:"moniker,omitempty"`
	Identity string `protobuf:"bytes,2,opt,name=identity,proto3" json:"identity,omitempty"`
	Website  string `protobuf:"bytes,3,opt,name=website,proto3" json:"website,omitempty"`
	Details  string `protobuf:"bytes,4,opt,name=details,proto3" json:"details,omitempty"`
}

func (m *Description) Reset()         { *m = Description{} }
func (m *Description) String() string { return proto.CompactTextString(m) }
func (*Description) ProtoMessage()    {}
func (*Description) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{0}
}
func (m *Description) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Description) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Description.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Description) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Description.Merge(m, src)
}
func (m *Description) XXX_Size() int {
	return m.Size()
}
func (m *Description) XXX_DiscardUnknown() {
	xxx_messageInfo_Description.DiscardUnknown(m)
}

var xxx_messageInfo_Description proto.InternalMessageInfo

func (m *Description) GetMoniker() string {
	if m != nil {
		return m.Moniker
	}
	return ""
}

func (m *Description) GetIdentity() string {
	if m != nil {
		return m.Identity
	}
	return ""
}

func (m *Description) GetWebsite() string {
	if m != nil {
		return m.Website
	}
	return ""
}

func (m *Description) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

// MsgCreateValidator defines an SDK message for creating a new validator.
type MsgCreateValidator struct {
	Description       Description                                   `protobuf:"bytes,1,opt,name=description,proto3" json:"description"`
	MinSelfDelegation types.DecCoin                                 `protobuf:"bytes,2,opt,name=min_self_delegation,json=minSelfDelegation,proto3" json:"min_self_delegation" yaml:"min_self_delegation"`
	DelegatorAddress  github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,3,opt,name=delegator_address,json=delegatorAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"delegator_address,omitempty" yaml:"delegator_address"`
	ValidatorAddress  github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,4,opt,name=validator_address,json=validatorAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator_address,omitempty" yaml:"validator_address"`
	PubKey            string                                        `protobuf:"bytes,5,opt,name=pub_key,json=pubKey,proto3" json:"pub_key,omitempty"`
}

func (m *MsgCreateValidator) Reset()         { *m = MsgCreateValidator{} }
func (m *MsgCreateValidator) String() string { return proto.CompactTextString(m) }
func (*MsgCreateValidator) ProtoMessage()    {}
func (*MsgCreateValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{1}
}
func (m *MsgCreateValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateValidator.Merge(m, src)
}
func (m *MsgCreateValidator) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateValidator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateValidator proto.InternalMessageInfo

func (m *MsgCreateValidator) GetDescription() Description {
	if m != nil {
		return m.Description
	}
	return Description{}
}

func (m *MsgCreateValidator) GetMinSelfDelegation() types.DecCoin {
	if m != nil {
		return m.MinSelfDelegation
	}
	return types.DecCoin{}
}

func (m *MsgCreateValidator) GetDelegatorAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.DelegatorAddress
	}
	return nil
}

func (m *MsgCreateValidator) GetValidatorAddress() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.ValidatorAddress
	}
	return nil
}

func (m *MsgCreateValidator) GetPubKey() string {
	if m != nil {
		return m.PubKey
	}
	return ""
}

// MsgEditValidator defines an SDK message for editing an existing validator.
type MsgEditValidator struct {
	Description      Description                                   `protobuf:"bytes,1,opt,name=description,proto3" json:"description"`
	ValidatorAddress github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator_address,omitempty" yaml:"validator_addresses"`
}

func (m *MsgEditValidator) Reset()         { *m = MsgEditValidator{} }
func (m *MsgEditValidator) String() string { return proto.CompactTextString(m) }
func (*MsgEditValidator) ProtoMessage()    {}
func (*MsgEditValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{2}
}
func (m *MsgEditValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgEditValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgEditValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgEditValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgEditValidator.Merge(m, src)
}
func (m *MsgEditValidator) XXX_Size() int {
	return m.Size()
}
func (m *MsgEditValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgEditValidator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgEditValidator proto.InternalMessageInfo

func (m *MsgEditValidator) GetDescription() Description {
	if m != nil {
		return m.Description
	}
	return Description{}
}

func (m *MsgEditValidator) GetValidatorAddress() github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.ValidatorAddress
	}
	return nil
}

type MsgDeposit struct {
	DelegatorAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"delegator_address,omitempty" yaml:"delegator_address"`
	Amount           types.DecCoin                                 `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount" yaml:"amount"`
}

func (m *MsgDeposit) Reset()         { *m = MsgDeposit{} }
func (m *MsgDeposit) String() string { return proto.CompactTextString(m) }
func (*MsgDeposit) ProtoMessage()    {}
func (*MsgDeposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{3}
}
func (m *MsgDeposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeposit.Merge(m, src)
}
func (m *MsgDeposit) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeposit) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeposit.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeposit proto.InternalMessageInfo

func (m *MsgDeposit) GetDelegatorAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.DelegatorAddress
	}
	return nil
}

func (m *MsgDeposit) GetAmount() types.DecCoin {
	if m != nil {
		return m.Amount
	}
	return types.DecCoin{}
}

type MsgWithdraw struct {
	DelegatorAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"delegator_address,omitempty" yaml:"delegator_address"`
	Amount           types.DecCoin                                 `protobuf:"bytes,2,opt,name=amount,proto3" json:"amount" yaml:"amount"`
}

func (m *MsgWithdraw) Reset()         { *m = MsgWithdraw{} }
func (m *MsgWithdraw) String() string { return proto.CompactTextString(m) }
func (*MsgWithdraw) ProtoMessage()    {}
func (*MsgWithdraw) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{4}
}
func (m *MsgWithdraw) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdraw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdraw.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdraw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdraw.Merge(m, src)
}
func (m *MsgWithdraw) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdraw) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdraw.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdraw proto.InternalMessageInfo

func (m *MsgWithdraw) GetDelegatorAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.DelegatorAddress
	}
	return nil
}

func (m *MsgWithdraw) GetAmount() types.DecCoin {
	if m != nil {
		return m.Amount
	}
	return types.DecCoin{}
}

type MsgAddShares struct {
	DelAddr  github_com_cosmos_cosmos_sdk_types.AccAddress   `protobuf:"bytes,1,opt,name=del_addr,json=delAddr,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"del_addr,omitempty" yaml:"delegator_address"`
	ValAddrs []github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,2,rep,name=val_addrs,json=valAddrs,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"val_addrs,omitempty" yaml:"validator_addresses"`
}

func (m *MsgAddShares) Reset()         { *m = MsgAddShares{} }
func (m *MsgAddShares) String() string { return proto.CompactTextString(m) }
func (*MsgAddShares) ProtoMessage()    {}
func (*MsgAddShares) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{5}
}
func (m *MsgAddShares) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAddShares) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAddShares.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAddShares) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAddShares.Merge(m, src)
}
func (m *MsgAddShares) XXX_Size() int {
	return m.Size()
}
func (m *MsgAddShares) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAddShares.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAddShares proto.InternalMessageInfo

func (m *MsgAddShares) GetDelAddr() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.DelAddr
	}
	return nil
}

func (m *MsgAddShares) GetValAddrs() []github_com_cosmos_cosmos_sdk_types.ValAddress {
	if m != nil {
		return m.ValAddrs
	}
	return nil
}

type MsgBindProxy struct {
	DelAddr      github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=del_addr,json=delAddr,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"del_addr,omitempty" yaml:"delegator_address"`
	ProxyAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,2,opt,name=proxy_address,json=proxyAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"proxy_address,omitempty" yaml:"proxy_address"`
}

func (m *MsgBindProxy) Reset()         { *m = MsgBindProxy{} }
func (m *MsgBindProxy) String() string { return proto.CompactTextString(m) }
func (*MsgBindProxy) ProtoMessage()    {}
func (*MsgBindProxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{6}
}
func (m *MsgBindProxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBindProxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBindProxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBindProxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBindProxy.Merge(m, src)
}
func (m *MsgBindProxy) XXX_Size() int {
	return m.Size()
}
func (m *MsgBindProxy) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBindProxy.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBindProxy proto.InternalMessageInfo

func (m *MsgBindProxy) GetDelAddr() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.DelAddr
	}
	return nil
}

func (m *MsgBindProxy) GetProxyAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.ProxyAddress
	}
	return nil
}

type MsgUnbindProxy struct {
	DelAddr github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=del_addr,json=delAddr,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"del_addr,omitempty" yaml:"delegator_address"`
}

func (m *MsgUnbindProxy) Reset()         { *m = MsgUnbindProxy{} }
func (m *MsgUnbindProxy) String() string { return proto.CompactTextString(m) }
func (*MsgUnbindProxy) ProtoMessage()    {}
func (*MsgUnbindProxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{7}
}
func (m *MsgUnbindProxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUnbindProxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUnbindProxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUnbindProxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUnbindProxy.Merge(m, src)
}
func (m *MsgUnbindProxy) XXX_Size() int {
	return m.Size()
}
func (m *MsgUnbindProxy) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUnbindProxy.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUnbindProxy proto.InternalMessageInfo

func (m *MsgUnbindProxy) GetDelAddr() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.DelAddr
	}
	return nil
}

type MsgRegProxy struct {
	ProxyAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=proxy_address,json=proxyAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"proxy_address,omitempty" yaml:"proxy_address"`
	Reg          bool                                          `protobuf:"varint,2,opt,name=reg,proto3" json:"reg,omitempty" yaml:"reg"`
}

func (m *MsgRegProxy) Reset()         { *m = MsgRegProxy{} }
func (m *MsgRegProxy) String() string { return proto.CompactTextString(m) }
func (*MsgRegProxy) ProtoMessage()    {}
func (*MsgRegProxy) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{8}
}
func (m *MsgRegProxy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegProxy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegProxy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegProxy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegProxy.Merge(m, src)
}
func (m *MsgRegProxy) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegProxy) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegProxy.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegProxy proto.InternalMessageInfo

func (m *MsgRegProxy) GetProxyAddress() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.ProxyAddress
	}
	return nil
}

func (m *MsgRegProxy) GetReg() bool {
	if m != nil {
		return m.Reg
	}
	return false
}

type MsgDestroyValidator struct {
	DelAddr github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=del_addr,json=delAddr,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"del_addr,omitempty" yaml:"delegator_address"`
}

func (m *MsgDestroyValidator) Reset()         { *m = MsgDestroyValidator{} }
func (m *MsgDestroyValidator) String() string { return proto.CompactTextString(m) }
func (*MsgDestroyValidator) ProtoMessage()    {}
func (*MsgDestroyValidator) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{9}
}
func (m *MsgDestroyValidator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDestroyValidator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDestroyValidator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDestroyValidator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDestroyValidator.Merge(m, src)
}
func (m *MsgDestroyValidator) XXX_Size() int {
	return m.Size()
}
func (m *MsgDestroyValidator) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDestroyValidator.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDestroyValidator proto.InternalMessageInfo

func (m *MsgDestroyValidator) GetDelAddr() github_com_cosmos_cosmos_sdk_types.AccAddress {
	if m != nil {
		return m.DelAddr
	}
	return nil
}

// CommissionRates defines the initial commission rates to be used for creating
// a validator.
type CommissionRates struct {
	Rate          github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,1,opt,name=rate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"rate"`
	MaxRate       github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,2,opt,name=max_rate,json=maxRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_rate" yaml:"max_rate"`
	MaxChangeRate github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,3,opt,name=max_change_rate,json=maxChangeRate,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"max_change_rate" yaml:"max_change_rate"`
}

func (m *CommissionRates) Reset()         { *m = CommissionRates{} }
func (m *CommissionRates) String() string { return proto.CompactTextString(m) }
func (*CommissionRates) ProtoMessage()    {}
func (*CommissionRates) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{10}
}
func (m *CommissionRates) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommissionRates) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommissionRates.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommissionRates) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommissionRates.Merge(m, src)
}
func (m *CommissionRates) XXX_Size() int {
	return m.Size()
}
func (m *CommissionRates) XXX_DiscardUnknown() {
	xxx_messageInfo_CommissionRates.DiscardUnknown(m)
}

var xxx_messageInfo_CommissionRates proto.InternalMessageInfo

// Commission defines a commission parameters for a given validator.
type Commission struct {
	CommissionRates `protobuf:"bytes,1,opt,name=commission_rates,json=commissionRates,proto3,embedded=commission_rates" json:"commission_rates"`
	UpdateTime      time.Time `protobuf:"bytes,2,opt,name=update_time,json=updateTime,proto3,stdtime" json:"update_time" yaml:"update_time"`
}

func (m *Commission) Reset()      { *m = Commission{} }
func (*Commission) ProtoMessage() {}
func (*Commission) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{11}
}
func (m *Commission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commission.Merge(m, src)
}
func (m *Commission) XXX_Size() int {
	return m.Size()
}
func (m *Commission) XXX_DiscardUnknown() {
	xxx_messageInfo_Commission.DiscardUnknown(m)
}

var xxx_messageInfo_Commission proto.InternalMessageInfo

func (m *Commission) GetUpdateTime() time.Time {
	if m != nil {
		return m.UpdateTime
	}
	return time.Time{}
}

// Validator defines the total amount of bond shares and their exchange rate to
// coins. Slashing results in a decrease in the exchange rate, allowing correct
// calculation of future undelegations without iterating over delegators.
// When coins are delegated to this validator, the validator is credited with a
// delegation whose number of bond shares is based on the amount of coins
// delegated divided by the current exchange rate. Voting power can be
// calculated as total bonded shares multiplied by exchange rate.
type Validator struct {
	OperatorAddress         github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,1,opt,name=operator_address,json=operatorAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"operator_address,omitempty" yaml:"operator_address"`
	ConsPubKey              string                                        `protobuf:"bytes,2,opt,name=cons_pubKey,json=consPubKey,proto3" json:"cons_pubKey,omitempty" yaml:"consensus_pubkey"`
	Jailed                  bool                                          `protobuf:"varint,3,opt,name=jailed,proto3" json:"jailed,omitempty"`
	Status                  github_com_cosmos_cosmos_sdk_types.BondStatus `protobuf:"varint,4,opt,name=status,proto3,casttype=github.com/cosmos/cosmos-sdk/types.BondStatus" json:"status,omitempty"`
	Tokens                  github_com_cosmos_cosmos_sdk_types.Int        `protobuf:"bytes,5,opt,name=tokens,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Int" json:"tokens"`
	DelegatorShares         github_com_cosmos_cosmos_sdk_types.Dec        `protobuf:"bytes,6,opt,name=delegator_shares,json=delegatorShares,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"delegator_shares" yaml:"delegator_shares"`
	Description             Description                                   `protobuf:"bytes,7,opt,name=description,proto3" json:"description"`
	UnbondingHeight         int64                                         `protobuf:"varint,8,opt,name=unbonding_height,json=unbondingHeight,proto3" json:"unbonding_height,omitempty" yaml:"unbonding_height"`
	UnbondingCompletionTime time.Time                                     `protobuf:"bytes,9,opt,name=unbonding_completion_time,json=unbondingCompletionTime,proto3,stdtime" json:"unbonding_completion_time" yaml:"unbonding_time"`
	Commission              Commission                                    `protobuf:"bytes,10,opt,name=commission,proto3" json:"commission"`
	MinSelfDelegation       github_com_cosmos_cosmos_sdk_types.Dec        `protobuf:"bytes,11,opt,name=min_self_delegation,json=minSelfDelegation,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_self_delegation" yaml:"min_self_delegation"`
}

func (m *Validator) Reset()      { *m = Validator{} }
func (*Validator) ProtoMessage() {}
func (*Validator) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{12}
}
func (m *Validator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validator.Merge(m, src)
}
func (m *Validator) XXX_Size() int {
	return m.Size()
}
func (m *Validator) XXX_DiscardUnknown() {
	xxx_messageInfo_Validator.DiscardUnknown(m)
}

var xxx_messageInfo_Validator proto.InternalMessageInfo

type Delegator struct {
	DelegatorAddress     github_com_cosmos_cosmos_sdk_types.AccAddress   `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"delegator_address,omitempty" yaml:"delegator_address"`
	ValidatorAddresses   []github_com_cosmos_cosmos_sdk_types.ValAddress `protobuf:"bytes,2,rep,name=validator_addresses,json=validatorAddresses,proto3,casttype=github.com/cosmos/cosmos-sdk/types.ValAddress" json:"validator_addresses,omitempty" yaml:"validator_addresses"`
	Shares               github_com_cosmos_cosmos_sdk_types.Dec          `protobuf:"bytes,3,opt,name=shares,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"shares" yaml:"shares"`
	Tokens               github_com_cosmos_cosmos_sdk_types.Dec          `protobuf:"bytes,4,opt,name=tokens,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"tokens" yaml:"tokens"`
	IsProxy              bool                                            `protobuf:"varint,5,opt,name=IsProxy,proto3" json:"IsProxy,omitempty"`
	TotalDelegatedTokens github_com_cosmos_cosmos_sdk_types.Dec          `protobuf:"bytes,6,opt,name=total_delegated_tokens,json=totalDelegatedTokens,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"total_delegated_tokens" yaml:"total_delegated_tokens"`
	ProxyAddress         github_com_cosmos_cosmos_sdk_types.AccAddress   `protobuf:"bytes,7,opt,name=proxy_address,json=proxyAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"proxy_address,omitempty" yaml:"proxy_address"`
}

func (m *Delegator) Reset()         { *m = Delegator{} }
func (m *Delegator) String() string { return proto.CompactTextString(m) }
func (*Delegator) ProtoMessage()    {}
func (*Delegator) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{13}
}
func (m *Delegator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Delegator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Delegator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Delegator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Delegator.Merge(m, src)
}
func (m *Delegator) XXX_Size() int {
	return m.Size()
}
func (m *Delegator) XXX_DiscardUnknown() {
	xxx_messageInfo_Delegator.DiscardUnknown(m)
}

var xxx_messageInfo_Delegator proto.InternalMessageInfo

type UndelegationInfo struct {
	DelegatorAddress github_com_cosmos_cosmos_sdk_types.AccAddress `protobuf:"bytes,1,opt,name=delegator_address,json=delegatorAddress,proto3,casttype=github.com/cosmos/cosmos-sdk/types.AccAddress" json:"delegator_address,omitempty" yaml:"delegator_address"`
	Quantity         github_com_cosmos_cosmos_sdk_types.Dec        `protobuf:"bytes,2,opt,name=quantity,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"quantity" yaml:"quantity"`
	CompletionTime   time.Time                                     `protobuf:"bytes,3,opt,name=completion_time,json=completionTime,proto3,stdtime" json:"completion_time" yaml:"completion_time"`
}

func (m *UndelegationInfo) Reset()      { *m = UndelegationInfo{} }
func (*UndelegationInfo) ProtoMessage() {}
func (*UndelegationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{14}
}
func (m *UndelegationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UndelegationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UndelegationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UndelegationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UndelegationInfo.Merge(m, src)
}
func (m *UndelegationInfo) XXX_Size() int {
	return m.Size()
}
func (m *UndelegationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UndelegationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UndelegationInfo proto.InternalMessageInfo

// Params defines the high level settings for staking
type Params struct {
	// time duration of unbonding
	UnbondingTime time.Duration `protobuf:"bytes,1,opt,name=unbonding_time,json=unbondingTime,proto3,stdduration" json:"unbonding_time" yaml:"unbonding_time"`
	// note: we need to be a bit careful about potential overflow here, since this is user-determined
	// maximum number of validators (max uint16 = 65535)
	MaxValidators uint32 `protobuf:"varint,2,opt,name=max_validators,json=maxValidators,proto3" json:"max_validators,omitempty" yaml:"max_bonded_validators"`
	// epoch for validator update
	Epoch              uint32 `protobuf:"varint,3,opt,name=epoch,proto3" json:"epoch,omitempty" yaml:"epoch"`
	MaxValsToAddShares uint32 `protobuf:"varint,4,opt,name=max_vals_to_add_shares,json=maxValsToAddShares,proto3" json:"max_vals_to_add_shares,omitempty" yaml:"max_validators_to_add_shares"`
	// bondable coin denomination
	BondDenom string `protobuf:"bytes,5,opt,name=bond_denom,json=bondDenom,proto3" json:"bond_denom,omitempty" yaml:"bond_denom"`
	// limited amount of delegate
	MinDelegation github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,6,opt,name=min_delegation,json=minDelegation,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_delegation" yaml:"min_delegation"`
	// validator's self declared minimum self delegation
	MinSelfDelegation github_com_cosmos_cosmos_sdk_types.Dec `protobuf:"bytes,7,opt,name=min_self_delegation,json=minSelfDelegation,proto3,customtype=github.com/cosmos/cosmos-sdk/types.Dec" json:"min_self_delegation" yaml:"min_self_delegation"`
}

func (m *Params) Reset()      { *m = Params{} }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_b25eed0b06a2c69c, []int{15}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Description)(nil), "okchain.staking.Description")
	proto.RegisterType((*MsgCreateValidator)(nil), "okchain.staking.MsgCreateValidator")
	proto.RegisterType((*MsgEditValidator)(nil), "okchain.staking.MsgEditValidator")
	proto.RegisterType((*MsgDeposit)(nil), "okchain.staking.MsgDeposit")
	proto.RegisterType((*MsgWithdraw)(nil), "okchain.staking.MsgWithdraw")
	proto.RegisterType((*MsgAddShares)(nil), "okchain.staking.MsgAddShares")
	proto.RegisterType((*MsgBindProxy)(nil), "okchain.staking.MsgBindProxy")
	proto.RegisterType((*MsgUnbindProxy)(nil), "okchain.staking.MsgUnbindProxy")
	proto.RegisterType((*MsgRegProxy)(nil), "okchain.staking.MsgRegProxy")
	proto.RegisterType((*MsgDestroyValidator)(nil), "okchain.staking.MsgDestroyValidator")
	proto.RegisterType((*CommissionRates)(nil), "okchain.staking.CommissionRates")
	proto.RegisterType((*Commission)(nil), "okchain.staking.Commission")
	proto.RegisterType((*Validator)(nil), "okchain.staking.Validator")
	proto.RegisterType((*Delegator)(nil), "okchain.staking.Delegator")
	proto.RegisterType((*UndelegationInfo)(nil), "okchain.staking.UndelegationInfo")
	proto.RegisterType((*Params)(nil), "okchain.staking.Params")
}

func init() { proto.RegisterFile("types/staking.proto", fileDescriptor_b25eed0b06a2c69c) }

var fileDescriptor_b25eed0b06a2c69c = []byte{
	// 1537 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0xcf, 0x6f, 0x1b, 0xc5,
	0x17, 0xcf, 0x26, 0x8e, 0xed, 0x3c, 0x27, 0x71, 0x3a, 0x69, 0x12, 0x37, 0xed, 0xd7, 0x9b, 0xef,
	0x22, 0xb5, 0xbd, 0xd4, 0x16, 0x85, 0x53, 0x84, 0x40, 0xd9, 0x98, 0xb6, 0x11, 0x8d, 0x5a, 0x6d,
	0x7f, 0x49, 0x14, 0x64, 0xad, 0x77, 0x27, 0xeb, 0xc5, 0xde, 0x1d, 0xb3, 0x33, 0x6e, 0x63, 0x54,
	0xa4, 0x5e, 0x2a, 0xf5, 0xd8, 0x63, 0x8f, 0xbd, 0x70, 0xe2, 0x4f, 0xe0, 0x1f, 0xa8, 0x38, 0x40,
	0x4f, 0xa8, 0x42, 0xc8, 0xa0, 0x96, 0x03, 0x07, 0xe0, 0xe0, 0x23, 0x27, 0xb4, 0x33, 0xb3, 0xbb,
	0xb6, 0xe3, 0xd2, 0x3a, 0x34, 0xa9, 0xc4, 0xcd, 0x33, 0xf3, 0xde, 0xe7, 0xbd, 0x79, 0xf3, 0x7e,
	0x7c, 0xbc, 0xb0, 0xc8, 0x3a, 0x2d, 0x4c, 0xcb, 0x94, 0x99, 0x0d, 0xd7, 0x77, 0x4a, 0xad, 0x80,
	0x30, 0x82, 0xf2, 0xa4, 0x61, 0xd5, 0x4d, 0xd7, 0x2f, 0xc9, 0xed, 0xd5, 0xa3, 0x0e, 0x71, 0x08,
	0x3f, 0x2b, 0x87, 0xbf, 0x84, 0xd8, 0xea, 0x31, 0x8b, 0x50, 0x8f, 0xd0, 0xaa, 0x38, 0x10, 0x0b,
	0x79, 0xa4, 0x3a, 0x84, 0x38, 0x4d, 0x5c, 0xe6, 0xab, 0x5a, 0x7b, 0xa7, 0xcc, 0x5c, 0x0f, 0x53,
	0x66, 0x7a, 0x2d, 0x29, 0x50, 0x1c, 0x16, 0xb0, 0xdb, 0x81, 0xc9, 0x5c, 0xe2, 0xcb, 0xf3, 0x45,
	0x01, 0x37, 0x80, 0xaa, 0x7d, 0x09, 0xb9, 0x0a, 0xa6, 0x56, 0xe0, 0xb6, 0x42, 0x49, 0x54, 0x80,
	0x8c, 0x47, 0x7c, 0xb7, 0x81, 0x83, 0x82, 0xb2, 0xa6, 0x9c, 0x9e, 0x31, 0xa2, 0x25, 0x5a, 0x85,
	0xac, 0x6b, 0x63, 0x9f, 0xb9, 0xac, 0x53, 0x98, 0xe4, 0x47, 0xf1, 0x3a, 0xd4, 0xba, 0x8d, 0x6b,
	0xd4, 0x65, 0xb8, 0x30, 0x25, 0xb4, 0xe4, 0x32, 0x3c, 0xb1, 0x31, 0x33, 0xdd, 0x26, 0x2d, 0xa4,
	0xc4, 0x89, 0x5c, 0xae, 0xa7, 0x7e, 0x7b, 0xa4, 0x2a, 0xda, 0x0f, 0x53, 0x80, 0xb6, 0xa9, 0xb3,
	0x19, 0x60, 0x93, 0xe1, 0xeb, 0x66, 0xd3, 0xb5, 0x4d, 0x46, 0x02, 0x54, 0x81, 0x9c, 0x9d, 0x78,
	0xc5, 0x5d, 0xc9, 0x9d, 0x3d, 0x51, 0x1a, 0x8a, 0x61, 0xa9, 0xcf, 0x73, 0x3d, 0xf5, 0xb8, 0xab,
	0x4e, 0x18, 0xfd, 0x6a, 0xc8, 0x82, 0x45, 0xcf, 0xf5, 0xab, 0x14, 0x37, 0x77, 0xaa, 0x36, 0x6e,
	0x62, 0x87, 0x47, 0x83, 0x7b, 0x9f, 0x3b, 0x9b, 0x2f, 0xc9, 0x38, 0x54, 0xb0, 0xb5, 0x49, 0x5c,
	0x5f, 0xd7, 0x42, 0x80, 0x5e, 0x57, 0x5d, 0xed, 0x98, 0x5e, 0x73, 0x5d, 0x1b, 0xa1, 0xa9, 0x19,
	0x47, 0x3c, 0xd7, 0xbf, 0x82, 0x9b, 0x3b, 0x95, 0x78, 0x0f, 0x7d, 0x01, 0x47, 0xa4, 0x04, 0x09,
	0xaa, 0xa6, 0x6d, 0x07, 0x98, 0x52, 0x1e, 0x85, 0x59, 0x7d, 0xbb, 0xd7, 0x55, 0x0b, 0x02, 0x6d,
	0x8f, 0x88, 0xf6, 0x57, 0x57, 0x3d, 0xe3, 0xb8, 0xac, 0xde, 0xae, 0x95, 0x2c, 0xe2, 0x95, 0x07,
	0xde, 0xe6, 0x0c, 0xb5, 0x1b, 0x65, 0x9e, 0x45, 0xa5, 0x0d, 0xcb, 0xda, 0x10, 0x1a, 0xc6, 0x42,
	0x0c, 0x22, 0x77, 0x42, 0xdb, 0xb7, 0xa2, 0x98, 0xc5, 0xb6, 0x53, 0xc3, 0xb6, 0xf7, 0x88, 0xbc,
	0xaa, 0xed, 0xeb, 0x66, 0x33, 0xb6, 0x1d, 0x83, 0x44, 0xb6, 0x57, 0x20, 0xd3, 0x6a, 0xd7, 0xaa,
	0x0d, 0xdc, 0x29, 0x4c, 0xf3, 0x97, 0x4d, 0xb7, 0xda, 0xb5, 0x8f, 0x70, 0x47, 0x3e, 0xec, 0x4f,
	0x0a, 0x2c, 0x6c, 0x53, 0xe7, 0x43, 0xdb, 0x65, 0xaf, 0xfb, 0x59, 0xef, 0x8c, 0xba, 0xf5, 0x24,
	0xbf, 0xf5, 0xa5, 0xe4, 0xfd, 0xf6, 0x88, 0xe0, 0xd7, 0x72, 0x6f, 0x79, 0xbd, 0xef, 0x14, 0x80,
	0x6d, 0xea, 0x54, 0x70, 0x8b, 0x50, 0x97, 0x8d, 0x4e, 0x02, 0xe5, 0x70, 0x92, 0xe0, 0x7d, 0x48,
	0x9b, 0x1e, 0x69, 0xfb, 0xec, 0x45, 0x89, 0xbd, 0x24, 0x13, 0x7b, 0x4e, 0x78, 0x21, 0x84, 0x35,
	0x43, 0x6a, 0xc9, 0x0b, 0x7d, 0xaf, 0x40, 0x6e, 0x9b, 0x3a, 0x37, 0x5c, 0x56, 0xb7, 0x03, 0xf3,
	0xf6, 0x7f, 0xe0, 0x46, 0xbf, 0x2b, 0x30, 0xbb, 0x4d, 0x9d, 0x0d, 0xdb, 0xbe, 0x52, 0x37, 0x03,
	0x4c, 0x51, 0x1d, 0xb2, 0x36, 0x6e, 0x72, 0x4f, 0x0f, 0xe6, 0x26, 0x19, 0x1b, 0xf3, 0xc4, 0x41,
	0x4d, 0x98, 0xb9, 0x65, 0x0a, 0x4b, 0x61, 0x66, 0x4e, 0x1d, 0x44, 0x66, 0x66, 0x6f, 0x89, 0xdf,
	0x51, 0x46, 0xfe, 0x29, 0xae, 0xab, 0xbb, 0xbe, 0x7d, 0x39, 0x20, 0xbb, 0x9d, 0x43, 0xbc, 0xae,
	0x0f, 0x73, 0xad, 0xd0, 0xe4, 0x50, 0x31, 0x6e, 0xf5, 0xba, 0xea, 0x51, 0x61, 0x6e, 0xe0, 0x78,
	0x1f, 0xa6, 0x66, 0x39, 0xc0, 0x60, 0x09, 0xde, 0x55, 0x60, 0x7e, 0x9b, 0x3a, 0xd7, 0xfc, 0xda,
	0xe1, 0x5f, 0x59, 0xba, 0xf0, 0x95, 0x28, 0x1a, 0x03, 0x3b, 0xc2, 0xfe, 0x9e, 0x40, 0x28, 0x07,
	0x1a, 0x08, 0xb4, 0x06, 0x53, 0x01, 0x76, 0x78, 0xb8, 0xb3, 0xfa, 0x7c, 0xaf, 0xab, 0x82, 0xb0,
	0x12, 0x60, 0x47, 0x33, 0xc2, 0x23, 0xe9, 0xe7, 0x3d, 0x05, 0x16, 0x79, 0xb7, 0xa2, 0x2c, 0x20,
	0x9d, 0xa4, 0x1f, 0x1f, 0x76, 0xbc, 0xbe, 0x9e, 0x84, 0xfc, 0x26, 0xf1, 0x3c, 0x97, 0x52, 0x97,
	0xf8, 0x86, 0xc9, 0x30, 0x45, 0x3a, 0xa4, 0x02, 0x93, 0x61, 0x41, 0x37, 0xf4, 0x52, 0x58, 0xd9,
	0x3f, 0x76, 0xd5, 0x93, 0xaf, 0x60, 0xa7, 0x82, 0x2d, 0x83, 0xeb, 0xa2, 0x4f, 0x20, 0xeb, 0x99,
	0xbb, 0x55, 0x8e, 0xc3, 0xb9, 0x89, 0xbe, 0x31, 0x1e, 0x4e, 0xaf, 0xab, 0xe6, 0xe5, 0xd8, 0x97,
	0x38, 0x9a, 0x91, 0xf1, 0xcc, 0xdd, 0xd0, 0x45, 0xd4, 0x82, 0x7c, 0xb8, 0x6b, 0xd5, 0x4d, 0xdf,
	0xc1, 0xc2, 0x08, 0x67, 0x39, 0xfa, 0x85, 0xb1, 0x8d, 0x2c, 0x27, 0x46, 0xfa, 0xe0, 0x34, 0x63,
	0xce, 0x33, 0x77, 0x37, 0xf9, 0x46, 0x68, 0x51, 0x46, 0xeb, 0x5b, 0x05, 0x20, 0x89, 0x16, 0xba,
	0x06, 0x0b, 0x56, 0xbc, 0xe2, 0x7a, 0x54, 0x4e, 0xd0, 0xb5, 0x3d, 0x13, 0x74, 0x28, 0xc8, 0x7a,
	0x36, 0xf4, 0xf4, 0x49, 0x57, 0x55, 0x8c, 0xbc, 0x35, 0x14, 0xff, 0x9b, 0x90, 0x6b, 0xb7, 0x6c,
	0x93, 0xe1, 0x6a, 0xc8, 0x27, 0x65, 0xc7, 0x5d, 0x2d, 0x09, 0x2e, 0x59, 0x8a, 0xb8, 0x64, 0xe9,
	0x6a, 0x44, 0x36, 0xf5, 0xa2, 0x6c, 0xbe, 0x48, 0xdc, 0xa5, 0x4f, 0x59, 0x7b, 0xf0, 0xb3, 0xaa,
	0x18, 0x20, 0x76, 0x42, 0x85, 0xf5, 0xec, 0xc3, 0x47, 0xea, 0x04, 0xbf, 0xcc, 0x37, 0x19, 0x98,
	0x49, 0x12, 0xef, 0x36, 0x2c, 0x90, 0x16, 0x0e, 0x46, 0x0c, 0x97, 0x8b, 0xbd, 0xae, 0xba, 0x22,
	0x90, 0x87, 0x25, 0xf6, 0xd1, 0x24, 0xf3, 0x11, 0x46, 0x54, 0x31, 0xef, 0x41, 0xce, 0x22, 0x3e,
	0xad, 0x0a, 0xae, 0x22, 0x93, 0xe5, 0x78, 0x62, 0x33, 0x3c, 0xc4, 0x3e, 0x6d, 0x73, 0x89, 0x06,
	0xee, 0x68, 0x06, 0x84, 0x5b, 0x97, 0xb9, 0x38, 0x5a, 0x86, 0xf4, 0x67, 0xa6, 0xdb, 0xc4, 0x36,
	0x4f, 0x80, 0xac, 0x21, 0x57, 0x68, 0x0b, 0xd2, 0x94, 0x99, 0xac, 0x2d, 0xc8, 0xd7, 0xb4, 0xfe,
	0xf6, 0x2b, 0x7a, 0xaa, 0x13, 0xdf, 0xbe, 0xc2, 0x15, 0x0d, 0x09, 0x80, 0xce, 0x41, 0x9a, 0x91,
	0x06, 0xf6, 0xa9, 0x60, 0x55, 0x63, 0x15, 0xc4, 0x96, 0xcf, 0x0c, 0xa9, 0x8d, 0x18, 0x24, 0x73,
	0xb5, 0x4a, 0xf9, 0x00, 0x2c, 0xa4, 0x39, 0xe2, 0xd6, 0xd8, 0x59, 0xbb, 0x32, 0xdc, 0x10, 0x04,
	0x9e, 0x66, 0xe4, 0xe3, 0x2d, 0x39, 0x62, 0x87, 0x08, 0x5e, 0x66, 0x7f, 0x04, 0xef, 0x1c, 0x2c,
	0xb4, 0xfd, 0x1a, 0xf1, 0x6d, 0xd7, 0x77, 0xaa, 0x75, 0xec, 0x3a, 0x75, 0x56, 0xc8, 0xae, 0x29,
	0xa7, 0xa7, 0xfa, 0x5f, 0x6a, 0x58, 0x42, 0x33, 0xf2, 0xf1, 0xd6, 0x05, 0xbe, 0x83, 0x3a, 0x70,
	0x2c, 0x91, 0xb2, 0x88, 0xd7, 0x6a, 0xe2, 0x10, 0x5f, 0x24, 0xfa, 0xcc, 0x4b, 0x13, 0xfd, 0xff,
	0x32, 0xd1, 0x97, 0x86, 0x0d, 0x26, 0xb9, 0xbe, 0x12, 0x6f, 0x6e, 0xc6, 0xf0, 0x21, 0x00, 0xda,
	0x00, 0x48, 0x0a, 0xad, 0x00, 0xdc, 0xd6, 0xf1, 0x7f, 0x28, 0x53, 0x19, 0x86, 0x3e, 0x25, 0x74,
	0x67, 0xf4, 0xbf, 0x97, 0x1c, 0x7f, 0xc4, 0x8b, 0x63, 0x3f, 0xe2, 0x78, 0x7f, 0x6b, 0xd6, 0x67,
	0xef, 0x3f, 0x52, 0x27, 0xe2, 0xea, 0x7d, 0x3a, 0x0d, 0x33, 0x95, 0xe8, 0xad, 0xdf, 0x28, 0x37,
	0xbc, 0xab, 0xc0, 0xe2, 0x08, 0x02, 0x75, 0x50, 0x2c, 0x0b, 0x0d, 0xf3, 0x7f, 0x4c, 0xd1, 0x0d,
	0x48, 0xcb, 0x82, 0x12, 0x63, 0xe0, 0x83, 0xb1, 0xdf, 0x42, 0xf2, 0xd6, 0xa8, 0x8c, 0x24, 0x5c,
	0x08, 0x2c, 0x6b, 0x3f, 0xf5, 0xef, 0x80, 0x05, 0x8a, 0x16, 0x37, 0x83, 0x02, 0x64, 0xb6, 0x28,
	0xa7, 0x28, 0xbc, 0xab, 0x64, 0x8d, 0x68, 0x89, 0xee, 0x29, 0xb0, 0xcc, 0x08, 0x33, 0x9b, 0x51,
	0x3e, 0x60, 0xbb, 0x2a, 0x7d, 0x10, 0xdd, 0xe2, 0xd2, 0xd8, 0x3e, 0xfc, 0x2f, 0xf2, 0x61, 0x14,
	0xaa, 0x66, 0x1c, 0xe5, 0x07, 0x95, 0x68, 0xff, 0xaa, 0xf0, 0x70, 0x0f, 0x73, 0xca, 0x1c, 0x2c,
	0x85, 0xcc, 0xde, 0x8f, 0x52, 0xfb, 0xd7, 0x49, 0x58, 0xb8, 0xe6, 0x27, 0xd5, 0xb0, 0xe5, 0xef,
	0x90, 0x37, 0x9a, 0xe1, 0x9f, 0x42, 0xf6, 0xf3, 0xb6, 0xd9, 0xf7, 0xa1, 0x65, 0xff, 0x64, 0x26,
	0xc2, 0xd1, 0x8c, 0x18, 0x12, 0x39, 0x90, 0x1f, 0x6e, 0x85, 0x53, 0x2f, 0x6d, 0x85, 0xd1, 0xb7,
	0x91, 0xe5, 0x68, 0x4a, 0x0e, 0x00, 0x88, 0x5e, 0x38, 0x6f, 0x0d, 0xb4, 0xc0, 0xa1, 0x0e, 0xf2,
	0x47, 0x0a, 0xd2, 0x97, 0xcd, 0xc0, 0xf4, 0x28, 0xb2, 0x60, 0x7e, 0xb0, 0x97, 0x4a, 0x1a, 0x73,
	0x6c, 0x8f, 0x03, 0x15, 0xf9, 0x01, 0xeb, 0x25, 0xad, 0xf8, 0x61, 0x68, 0x7e, 0x2e, 0xde, 0xe4,
	0x0d, 0xf8, 0x3c, 0xcc, 0x87, 0x2c, 0x2b, 0x2e, 0x5f, 0xf1, 0xa7, 0x64, 0x4e, 0x5f, 0xeb, 0x75,
	0xd5, 0x13, 0x09, 0x0b, 0x0b, 0x55, 0xb0, 0xdd, 0x27, 0x26, 0xb8, 0x58, 0xcc, 0x54, 0x28, 0x3a,
	0x09, 0xd3, 0xb8, 0x45, 0xac, 0x3a, 0x8f, 0xd2, 0x9c, 0xbe, 0xd0, 0xeb, 0xaa, 0xb3, 0x42, 0x9f,
	0x6f, 0x6b, 0x86, 0x38, 0x46, 0x37, 0x61, 0x59, 0x1a, 0xa4, 0x55, 0x46, 0xc2, 0x8c, 0x88, 0xc6,
	0x6e, 0x8a, 0x2b, 0x9e, 0xea, 0x75, 0xd5, 0xb7, 0x12, 0xc3, 0x89, 0xc5, 0x41, 0x69, 0xcd, 0x40,
	0xc2, 0x3e, 0xbd, 0x4a, 0x92, 0xbf, 0xae, 0xef, 0x02, 0x84, 0x9e, 0x56, 0x6d, 0xec, 0x13, 0x4f,
	0x32, 0x83, 0xa5, 0x5e, 0x57, 0x3d, 0x22, 0x00, 0x93, 0x33, 0xcd, 0x98, 0x09, 0x17, 0x95, 0xf0,
	0x37, 0xf2, 0x61, 0x3e, 0x6c, 0xf7, 0x7d, 0xc3, 0x43, 0xd4, 0xf4, 0xf9, 0xb1, 0xf3, 0x69, 0x29,
	0x19, 0x1e, 0xfd, 0x73, 0x63, 0xce, 0x73, 0xfd, 0xbe, 0x4f, 0x61, 0x2f, 0x98, 0x58, 0x99, 0x37,
	0x30, 0xb1, 0xf4, 0x8d, 0xc7, 0xcf, 0x8a, 0xca, 0x93, 0x67, 0x45, 0xe5, 0x97, 0x67, 0x45, 0xe5,
	0xc1, 0xf3, 0xe2, 0xc4, 0x93, 0xe7, 0xc5, 0x89, 0xa7, 0xcf, 0x8b, 0x13, 0x1f, 0x9f, 0xea, 0x73,
	0x80, 0x34, 0xf0, 0x6e, 0x59, 0x4e, 0xe5, 0xf2, 0x6e, 0xf4, 0xc9, 0x56, 0x78, 0x51, 0x4b, 0xf3,
	0x3c, 0x7c, 0xe7, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x84, 0x4c, 0xa1, 0xb4, 0xd0, 0x15, 0x00,
	0x00,
}

func (this *Description) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Description)
	if !ok {
		that2, ok := that.(Description)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Moniker != that1.Moniker {
		return false
	}
	if this.Identity != that1.Identity {
		return false
	}
	if this.Website != that1.Website {
		return false
	}
	if this.Details != that1.Details {
		return false
	}
	return true
}
func (this *MsgCreateValidator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgCreateValidator)
	if !ok {
		that2, ok := that.(MsgCreateValidator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Description.Equal(&that1.Description) {
		return false
	}
	if !this.MinSelfDelegation.Equal(&that1.MinSelfDelegation) {
		return false
	}
	if !bytes.Equal(this.DelegatorAddress, that1.DelegatorAddress) {
		return false
	}
	if !bytes.Equal(this.ValidatorAddress, that1.ValidatorAddress) {
		return false
	}
	if this.PubKey != that1.PubKey {
		return false
	}
	return true
}
func (this *MsgEditValidator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgEditValidator)
	if !ok {
		that2, ok := that.(MsgEditValidator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Description.Equal(&that1.Description) {
		return false
	}
	if !bytes.Equal(this.ValidatorAddress, that1.ValidatorAddress) {
		return false
	}
	return true
}
func (this *MsgDeposit) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgDeposit)
	if !ok {
		that2, ok := that.(MsgDeposit)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DelegatorAddress, that1.DelegatorAddress) {
		return false
	}
	if !this.Amount.Equal(&that1.Amount) {
		return false
	}
	return true
}
func (this *MsgWithdraw) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgWithdraw)
	if !ok {
		that2, ok := that.(MsgWithdraw)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DelegatorAddress, that1.DelegatorAddress) {
		return false
	}
	if !this.Amount.Equal(&that1.Amount) {
		return false
	}
	return true
}
func (this *MsgAddShares) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgAddShares)
	if !ok {
		that2, ok := that.(MsgAddShares)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DelAddr, that1.DelAddr) {
		return false
	}
	if len(this.ValAddrs) != len(that1.ValAddrs) {
		return false
	}
	for i := range this.ValAddrs {
		if !bytes.Equal(this.ValAddrs[i], that1.ValAddrs[i]) {
			return false
		}
	}
	return true
}
func (this *MsgBindProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgBindProxy)
	if !ok {
		that2, ok := that.(MsgBindProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DelAddr, that1.DelAddr) {
		return false
	}
	if !bytes.Equal(this.ProxyAddress, that1.ProxyAddress) {
		return false
	}
	return true
}
func (this *MsgUnbindProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgUnbindProxy)
	if !ok {
		that2, ok := that.(MsgUnbindProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DelAddr, that1.DelAddr) {
		return false
	}
	return true
}
func (this *MsgRegProxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgRegProxy)
	if !ok {
		that2, ok := that.(MsgRegProxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.ProxyAddress, that1.ProxyAddress) {
		return false
	}
	if this.Reg != that1.Reg {
		return false
	}
	return true
}
func (this *MsgDestroyValidator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MsgDestroyValidator)
	if !ok {
		that2, ok := that.(MsgDestroyValidator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DelAddr, that1.DelAddr) {
		return false
	}
	return true
}
func (this *CommissionRates) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CommissionRates)
	if !ok {
		that2, ok := that.(CommissionRates)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rate.Equal(that1.Rate) {
		return false
	}
	if !this.MaxRate.Equal(that1.MaxRate) {
		return false
	}
	if !this.MaxChangeRate.Equal(that1.MaxChangeRate) {
		return false
	}
	return true
}
func (this *Commission) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Commission)
	if !ok {
		that2, ok := that.(Commission)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.CommissionRates.Equal(&that1.CommissionRates) {
		return false
	}
	if !this.UpdateTime.Equal(that1.UpdateTime) {
		return false
	}
	return true
}
func (this *Validator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Validator)
	if !ok {
		that2, ok := that.(Validator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.OperatorAddress, that1.OperatorAddress) {
		return false
	}
	if this.ConsPubKey != that1.ConsPubKey {
		return false
	}
	if this.Jailed != that1.Jailed {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.Tokens.Equal(that1.Tokens) {
		return false
	}
	if !this.DelegatorShares.Equal(that1.DelegatorShares) {
		return false
	}
	if !this.Description.Equal(&that1.Description) {
		return false
	}
	if this.UnbondingHeight != that1.UnbondingHeight {
		return false
	}
	if !this.UnbondingCompletionTime.Equal(that1.UnbondingCompletionTime) {
		return false
	}
	if !this.Commission.Equal(&that1.Commission) {
		return false
	}
	if !this.MinSelfDelegation.Equal(that1.MinSelfDelegation) {
		return false
	}
	return true
}
func (this *Delegator) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Delegator)
	if !ok {
		that2, ok := that.(Delegator)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DelegatorAddress, that1.DelegatorAddress) {
		return false
	}
	if len(this.ValidatorAddresses) != len(that1.ValidatorAddresses) {
		return false
	}
	for i := range this.ValidatorAddresses {
		if !bytes.Equal(this.ValidatorAddresses[i], that1.ValidatorAddresses[i]) {
			return false
		}
	}
	if !this.Shares.Equal(that1.Shares) {
		return false
	}
	if !this.Tokens.Equal(that1.Tokens) {
		return false
	}
	if this.IsProxy != that1.IsProxy {
		return false
	}
	if !this.TotalDelegatedTokens.Equal(that1.TotalDelegatedTokens) {
		return false
	}
	if !bytes.Equal(this.ProxyAddress, that1.ProxyAddress) {
		return false
	}
	return true
}
func (this *UndelegationInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UndelegationInfo)
	if !ok {
		that2, ok := that.(UndelegationInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.DelegatorAddress, that1.DelegatorAddress) {
		return false
	}
	if !this.Quantity.Equal(that1.Quantity) {
		return false
	}
	if !this.CompletionTime.Equal(that1.CompletionTime) {
		return false
	}
	return true
}
func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UnbondingTime != that1.UnbondingTime {
		return false
	}
	if this.MaxValidators != that1.MaxValidators {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if this.MaxValsToAddShares != that1.MaxValsToAddShares {
		return false
	}
	if this.BondDenom != that1.BondDenom {
		return false
	}
	if !this.MinDelegation.Equal(that1.MinDelegation) {
		return false
	}
	if !this.MinSelfDelegation.Equal(that1.MinSelfDelegation) {
		return false
	}
	return true
}
func (m *Description) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Description) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Description) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Details) > 0 {
		i -= len(m.Details)
		copy(dAtA[i:], m.Details)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.Details)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Website) > 0 {
		i -= len(m.Website)
		copy(dAtA[i:], m.Website)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.Website)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Moniker) > 0 {
		i -= len(m.Moniker)
		copy(dAtA[i:], m.Moniker)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.Moniker)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.MinSelfDelegation.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgEditValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgEditValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgEditValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *MsgDeposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdraw) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdraw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdraw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Amount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAddShares) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAddShares) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAddShares) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValAddrs) > 0 {
		for iNdEx := len(m.ValAddrs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ValAddrs[iNdEx])
			copy(dAtA[i:], m.ValAddrs[iNdEx])
			i = encodeVarintStaking(dAtA, i, uint64(len(m.ValAddrs[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DelAddr) > 0 {
		i -= len(m.DelAddr)
		copy(dAtA[i:], m.DelAddr)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.DelAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgBindProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBindProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBindProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProxyAddress) > 0 {
		i -= len(m.ProxyAddress)
		copy(dAtA[i:], m.ProxyAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.ProxyAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DelAddr) > 0 {
		i -= len(m.DelAddr)
		copy(dAtA[i:], m.DelAddr)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.DelAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUnbindProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUnbindProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUnbindProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelAddr) > 0 {
		i -= len(m.DelAddr)
		copy(dAtA[i:], m.DelAddr)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.DelAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegProxy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegProxy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegProxy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Reg {
		i--
		if m.Reg {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProxyAddress) > 0 {
		i -= len(m.ProxyAddress)
		copy(dAtA[i:], m.ProxyAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.ProxyAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDestroyValidator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDestroyValidator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDestroyValidator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelAddr) > 0 {
		i -= len(m.DelAddr)
		copy(dAtA[i:], m.DelAddr)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.DelAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommissionRates) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommissionRates) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommissionRates) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MaxChangeRate.Size()
		i -= size
		if _, err := m.MaxChangeRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	{
		size := m.MaxRate.Size()
		i -= size
		if _, err := m.MaxRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	{
		size := m.Rate.Size()
		i -= size
		if _, err := m.Rate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Commission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n6, err6 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UpdateTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateTime):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintStaking(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x12
	{
		size, err := m.CommissionRates.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Validator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Validator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinSelfDelegation.Size()
		i -= size
		if _, err := m.MinSelfDelegation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.Commission.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	n9, err9 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.UnbondingCompletionTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.UnbondingCompletionTime):])
	if err9 != nil {
		return 0, err9
	}
	i -= n9
	i = encodeVarintStaking(dAtA, i, uint64(n9))
	i--
	dAtA[i] = 0x4a
	if m.UnbondingHeight != 0 {
		i = encodeVarintStaking(dAtA, i, uint64(m.UnbondingHeight))
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.Description.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.DelegatorShares.Size()
		i -= size
		if _, err := m.DelegatorShares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size := m.Tokens.Size()
		i -= size
		if _, err := m.Tokens.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.Status != 0 {
		i = encodeVarintStaking(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ConsPubKey) > 0 {
		i -= len(m.ConsPubKey)
		copy(dAtA[i:], m.ConsPubKey)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.ConsPubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OperatorAddress) > 0 {
		i -= len(m.OperatorAddress)
		copy(dAtA[i:], m.OperatorAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.OperatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Delegator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Delegator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Delegator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProxyAddress) > 0 {
		i -= len(m.ProxyAddress)
		copy(dAtA[i:], m.ProxyAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.ProxyAddress)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size := m.TotalDelegatedTokens.Size()
		i -= size
		if _, err := m.TotalDelegatedTokens.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.IsProxy {
		i--
		if m.IsProxy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	{
		size := m.Tokens.Size()
		i -= size
		if _, err := m.Tokens.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	{
		size := m.Shares.Size()
		i -= size
		if _, err := m.Shares.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.ValidatorAddresses) > 0 {
		for iNdEx := len(m.ValidatorAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ValidatorAddresses[iNdEx])
			copy(dAtA[i:], m.ValidatorAddresses[iNdEx])
			i = encodeVarintStaking(dAtA, i, uint64(len(m.ValidatorAddresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UndelegationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UndelegationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UndelegationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n11, err11 := github_com_gogo_protobuf_types.StdTimeMarshalTo(m.CompletionTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(m.CompletionTime):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintStaking(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x1a
	{
		size := m.Quantity.Size()
		i -= size
		if _, err := m.Quantity.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.MinSelfDelegation.Size()
		i -= size
		if _, err := m.MinSelfDelegation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size := m.MinDelegation.Size()
		i -= size
		if _, err := m.MinDelegation.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintStaking(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.BondDenom) > 0 {
		i -= len(m.BondDenom)
		copy(dAtA[i:], m.BondDenom)
		i = encodeVarintStaking(dAtA, i, uint64(len(m.BondDenom)))
		i--
		dAtA[i] = 0x2a
	}
	if m.MaxValsToAddShares != 0 {
		i = encodeVarintStaking(dAtA, i, uint64(m.MaxValsToAddShares))
		i--
		dAtA[i] = 0x20
	}
	if m.Epoch != 0 {
		i = encodeVarintStaking(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxValidators != 0 {
		i = encodeVarintStaking(dAtA, i, uint64(m.MaxValidators))
		i--
		dAtA[i] = 0x10
	}
	n12, err12 := github_com_gogo_protobuf_types.StdDurationMarshalTo(m.UnbondingTime, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdDuration(m.UnbondingTime):])
	if err12 != nil {
		return 0, err12
	}
	i -= n12
	i = encodeVarintStaking(dAtA, i, uint64(n12))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func encodeVarintStaking(dAtA []byte, offset int, v uint64) int {
	offset -= sovStaking(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Description) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Moniker)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = len(m.Website)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = len(m.Details)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	return n
}

func (m *MsgCreateValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Description.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = m.MinSelfDelegation.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	return n
}

func (m *MsgEditValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Description.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	return n
}

func (m *MsgDeposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovStaking(uint64(l))
	return n
}

func (m *MsgWithdraw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = m.Amount.Size()
	n += 1 + l + sovStaking(uint64(l))
	return n
}

func (m *MsgAddShares) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelAddr)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	if len(m.ValAddrs) > 0 {
		for _, b := range m.ValAddrs {
			l = len(b)
			n += 1 + l + sovStaking(uint64(l))
		}
	}
	return n
}

func (m *MsgBindProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelAddr)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = len(m.ProxyAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	return n
}

func (m *MsgUnbindProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelAddr)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	return n
}

func (m *MsgRegProxy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProxyAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	if m.Reg {
		n += 2
	}
	return n
}

func (m *MsgDestroyValidator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelAddr)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	return n
}

func (m *CommissionRates) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Rate.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = m.MaxRate.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = m.MaxChangeRate.Size()
	n += 1 + l + sovStaking(uint64(l))
	return n
}

func (m *Commission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.CommissionRates.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UpdateTime)
	n += 1 + l + sovStaking(uint64(l))
	return n
}

func (m *Validator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OperatorAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = len(m.ConsPubKey)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	if m.Jailed {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovStaking(uint64(m.Status))
	}
	l = m.Tokens.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = m.DelegatorShares.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = m.Description.Size()
	n += 1 + l + sovStaking(uint64(l))
	if m.UnbondingHeight != 0 {
		n += 1 + sovStaking(uint64(m.UnbondingHeight))
	}
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.UnbondingCompletionTime)
	n += 1 + l + sovStaking(uint64(l))
	l = m.Commission.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = m.MinSelfDelegation.Size()
	n += 1 + l + sovStaking(uint64(l))
	return n
}

func (m *Delegator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	if len(m.ValidatorAddresses) > 0 {
		for _, b := range m.ValidatorAddresses {
			l = len(b)
			n += 1 + l + sovStaking(uint64(l))
		}
	}
	l = m.Shares.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = m.Tokens.Size()
	n += 1 + l + sovStaking(uint64(l))
	if m.IsProxy {
		n += 2
	}
	l = m.TotalDelegatedTokens.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = len(m.ProxyAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	return n
}

func (m *UndelegationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = m.Quantity.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = github_com_gogo_protobuf_types.SizeOfStdTime(m.CompletionTime)
	n += 1 + l + sovStaking(uint64(l))
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = github_com_gogo_protobuf_types.SizeOfStdDuration(m.UnbondingTime)
	n += 1 + l + sovStaking(uint64(l))
	if m.MaxValidators != 0 {
		n += 1 + sovStaking(uint64(m.MaxValidators))
	}
	if m.Epoch != 0 {
		n += 1 + sovStaking(uint64(m.Epoch))
	}
	if m.MaxValsToAddShares != 0 {
		n += 1 + sovStaking(uint64(m.MaxValsToAddShares))
	}
	l = len(m.BondDenom)
	if l > 0 {
		n += 1 + l + sovStaking(uint64(l))
	}
	l = m.MinDelegation.Size()
	n += 1 + l + sovStaking(uint64(l))
	l = m.MinSelfDelegation.Size()
	n += 1 + l + sovStaking(uint64(l))
	return n
}

func sovStaking(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStaking(x uint64) (n int) {
	return sovStaking(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Description) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Description: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Description: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Moniker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Moniker = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Website", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Website = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSelfDelegation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinSelfDelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = append(m.DelegatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.DelegatorAddress == nil {
				m.DelegatorAddress = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = append(m.ValidatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ValidatorAddress == nil {
				m.ValidatorAddress = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgEditValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgEditValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgEditValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = append(m.ValidatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ValidatorAddress == nil {
				m.ValidatorAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = append(m.DelegatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.DelegatorAddress == nil {
				m.DelegatorAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdraw) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdraw: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdraw: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = append(m.DelegatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.DelegatorAddress == nil {
				m.DelegatorAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Amount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAddShares) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAddShares: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAddShares: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelAddr = append(m.DelAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.DelAddr == nil {
				m.DelAddr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValAddrs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValAddrs = append(m.ValAddrs, make([]byte, postIndex-iNdEx))
			copy(m.ValAddrs[len(m.ValAddrs)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgBindProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBindProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBindProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelAddr = append(m.DelAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.DelAddr == nil {
				m.DelAddr = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyAddress = append(m.ProxyAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ProxyAddress == nil {
				m.ProxyAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUnbindProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUnbindProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUnbindProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelAddr = append(m.DelAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.DelAddr == nil {
				m.DelAddr = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegProxy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegProxy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegProxy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyAddress = append(m.ProxyAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ProxyAddress == nil {
				m.ProxyAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reg", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reg = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDestroyValidator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDestroyValidator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDestroyValidator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelAddr", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelAddr = append(m.DelAddr[:0], dAtA[iNdEx:postIndex]...)
			if m.DelAddr == nil {
				m.DelAddr = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommissionRates) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommissionRates: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommissionRates: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxChangeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MaxChangeRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommissionRates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommissionRates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UpdateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OperatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OperatorAddress = append(m.OperatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.OperatorAddress == nil {
				m.OperatorAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsPubKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConsPubKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= github_com_cosmos_cosmos_sdk_types.BondStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DelegatorShares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Description.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingHeight", wireType)
			}
			m.UnbondingHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingCompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.UnbondingCompletionTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commission", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Commission.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSelfDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinSelfDelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delegator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delegator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delegator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = append(m.DelegatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.DelegatorAddress == nil {
				m.DelegatorAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddresses", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddresses = append(m.ValidatorAddresses, make([]byte, postIndex-iNdEx))
			copy(m.ValidatorAddresses[len(m.ValidatorAddresses)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shares.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Tokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsProxy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsProxy = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalDelegatedTokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TotalDelegatedTokens.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyAddress = append(m.ProxyAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.ProxyAddress == nil {
				m.ProxyAddress = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UndelegationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UndelegationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UndelegationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = append(m.DelegatorAddress[:0], dAtA[iNdEx:postIndex]...)
			if m.DelegatorAddress == nil {
				m.DelegatorAddress = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Quantity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(&m.CompletionTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_gogo_protobuf_types.StdDurationUnmarshal(&m.UnbondingTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValidators", wireType)
			}
			m.MaxValidators = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValidators |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxValsToAddShares", wireType)
			}
			m.MaxValsToAddShares = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxValsToAddShares |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinDelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSelfDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStaking
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStaking
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinSelfDelegation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStaking(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStaking
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStaking(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStaking
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStaking
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStaking
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStaking
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStaking
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStaking        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStaking          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStaking = fmt.Errorf("proto: unexpected end of group")
)
